#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <string.h>
#include <signal.h>
#include "parser.h"

// Definición de la estructura de trabajo (job)
typedef struct job {
    int id;
    pid_t pid;
    char command[1024];
    char status[1024];
    int active; // Para comprobar si el mandato sigue activo
    struct job* next; // Puntero al siguiente trabajo
} job_t;

// Puntero al inicio de la lista de trabajos
job_t* job_list = NULL;
int next_job_id = 1;

// Declaración de funciones
void manejador_hijos(int sig);
void fg(char* index);
job_t* agregar_job(pid_t pid, const char* command);
void eliminar_job(pid_t pid);
job_t* buscar_job_por_pid(pid_t pid);

int main() {
    signal(SIGINT, SIG_IGN); // Ignorar SIGINT
    signal(SIGQUIT, SIG_IGN); // Ignorar SIGQUIT
    signal(SIGCHLD, manejador_hijos); // Manejar SIGCHLD

    while (1) {
        printf("msh> ");
        fflush(stdout);

        char buff[1024];
        if (fgets(buff, sizeof(buff), stdin) == 0) {
            break; // Si EOF, salir
        }

        tline* line = tokenize(buff);

        // Comando interno `jobs`
        if (strcmp(buff, "jobs\n") == 0) {
            job_t* current = job_list;
            while (current != NULL) {
                if (current->active) {
                    printf("[%d]+ %-7s %s\n", current->id, current->status, current->command);
                }
                current = current->next;
            }
        }
        // Comando interno `fg`
        else if (strncmp(buff, "fg ", 3) == 0 || strcmp(buff, "fg\n") == 0) {
            char* index = strtok(buff + 3, "\n");
            fg(index);
        } else if (line != NULL) {
            int numcommands = line->ncommands;
            int pipefd[numcommands - 1][2];

            for (int i = 0; i < numcommands - 1; i++) {
                if (pipe(pipefd[i]) == -1) {
                    fprintf(stderr, "Error al crear el pipe\n");
                    return -1;
                }
            }

            for (int i = 0; i < numcommands; i++) {
                pid_t pid = fork();

                if (pid == -1) {
                    fprintf(stderr, "Error al crear el proceso hijo\n");
                    return -1;
                }

                if (pid == 0) {
                    if (line->background == 0) {
                        signal(SIGINT, SIG_DFL);
                        signal(SIGQUIT, SIG_DFL);
                    }

                    if (i > 0) {
                        dup2(pipefd[i - 1][0], STDIN_FILENO);
                    }
                    if (i < numcommands - 1) {
                        dup2(pipefd[i][1], STDOUT_FILENO);
                    }

                    for (int j = 0; j < numcommands - 1; j++) {
                        close(pipefd[j][0]);
                        close(pipefd[j][1]);
                    }

                    tcommand* cmd = &line->commands[i];
                    if (cmd->filename == NULL) {
                        printf("%s: No se encuentra el mandato\n", cmd->argv[0]);
                        return -1;
                    }

                    execv(cmd->filename, cmd->argv);
                    fprintf(stderr, "Error al ejecutar el comando %s\n", cmd->filename);
                    return -1;
                } else {
                    if (line->background == 1) {
                        agregar_job(pid, line->commands[i].filename);
                    }
                }
            }

            for (int i = 0; i < numcommands - 1; i++) {
                close(pipefd[i][0]);
                close(pipefd[i][1]);
            }

            if (line->background == 0) {
                for (int i = 0; i < numcommands; i++) {
                    wait(NULL);
                }
            }
        }
    }
    return 0;
}

void manejador_hijos(int signo) {
    pid_t pid;
    int status;

    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
        job_t* job = buscar_job_por_pid(pid);
        if (job != NULL) {
            job->active = 0;
            if (WIFEXITED(status)) {
                strncpy(job->status, "Done", sizeof(job->status));
            }
            eliminar_job(pid);
        }
    }
}

void fg(char* index) {
    job_t* job = NULL;
    int job_id = (index != NULL) ? atoi(index) : -1;

    // Buscar el trabajo en la lista manualmente
    job_t* current = job_list;
    while (current != NULL) {
        if ((job_id == -1 && current->active) || (current->id == job_id && current->active)) {
            job = current;
            break;
        }
        current = current->next;
    }

    if (job == NULL) {
        fprintf(stderr, "fg: No existe un trabajo activo con ese ID\n");
        return;
    }

    printf("Reanudando proceso [%d] %s\n", job->id, job->command);
    waitpid(job->pid, NULL, 0);

    job->active = 0;
    strncpy(job->status, "Done", sizeof(job->status));
    eliminar_job(job->pid);
}

job_t* agregar_job(pid_t pid, const char* command) {
    job_t* new_job = (job_t*)malloc(sizeof(job_t));
    new_job->id = next_job_id++;
    new_job->pid = pid;
    new_job->active = 1;
    strncpy(new_job->command, command, sizeof(new_job->command));
    strncpy(new_job->status, "Running", sizeof(new_job->status));
    new_job->next = job_list;
    job_list = new_job;
    return new_job;
}

void eliminar_job(pid_t pid) {
    job_t* current = job_list;
    job_t* prev = NULL;

    while (current != NULL) {
        if (current->pid == pid) {
            if (prev == NULL) {
                job_list = current->next;
            } else {
                prev->next = current->next;
            }
            free(current);
            return;
        }
        prev = current;
        current = current->next;
    }
}

job_t* buscar_job_por_pid(pid_t pid) {
    job_t* current = job_list;
    while (current != NULL) {
        if (current->pid == pid) {
            return current;
        }
        current = current->next;
    }
    return NULL;
}
